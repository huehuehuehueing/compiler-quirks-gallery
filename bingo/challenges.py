"""
Challenge pool for the Compiler Optimization Bingo card generator.

Each challenge maps to a concept demonstrated in the gallery's source files.
Difficulty: 1=easy(★), 2=medium(★★), 3=hard(★★★).
"""

from dataclasses import dataclass, field
from typing import List


@dataclass
class Challenge:
    id: str
    challenge_type: str   # flag_effect | asm_pattern | scenario_compare |
                          # compiler_diff | security | true_false
    category: str         # Gallery section name
    difficulty: int       # 1, 2, or 3
    prompt: str           # Question shown face-up on the card
    answer: str           # Hidden answer revealed on flip
    hint: str = ""        # Gallery reference
    accept: List[str] = field(default_factory=list)  # Quiz-mode accepted keywords


CHALLENGE_POOL: List[Challenge] = [
    # ===================================================================
    # Flag → Effect  (9 challenges)
    # ===================================================================
    Challenge(
        id="flag_stack_protector",
        challenge_type="flag_effect",
        category="hardening",
        difficulty=1,
        prompt="This flag tells GCC to insert a stack canary between local variables and the return address",
        answer="-fstack-protector-all",
        hint="See: hardening/stack-protector",
        accept=["stack-protector", "stack protector"],
    ),
    Challenge(
        id="flag_fast_math",
        challenge_type="flag_effect",
        category="arithmetic",
        difficulty=1,
        prompt="This flag (or -Ofast) lets the compiler reorder floating-point operations and assume no NaN values",
        answer="-ffast-math",
        hint="See: arithmetic/fast-math",
        accept=["fast-math", "fast math", "ffast"],
    ),
    Challenge(
        id="flag_cf_protection",
        challenge_type="flag_effect",
        category="hardening",
        difficulty=2,
        prompt="This GCC/Clang flag causes the compiler to insert ENDBR64 instructions at function entries",
        answer="-fcf-protection=full",
        hint="See: hardening/cf-protection",
        accept=["cf-protection", "cf protection"],
    ),
    Challenge(
        id="flag_fortify_source",
        challenge_type="flag_effect",
        category="hardening",
        difficulty=2,
        prompt="This preprocessor define replaces strcpy/memcpy with bounds-checked variants like __memcpy_chk",
        answer="-D_FORTIFY_SOURCE=2",
        hint="See: hardening/fortify-source",
        accept=["fortify_source", "fortify source"],
    ),
    Challenge(
        id="flag_fwrapv",
        challenge_type="flag_effect",
        category="arithmetic",
        difficulty=2,
        prompt="This flag makes signed integer overflow well-defined (two's complement wrapping) instead of UB",
        answer="-fwrapv",
        hint="See: security/wrapv-vs-ubsan",
        accept=["wrapv", "fwrapv"],
    ),
    Challenge(
        id="flag_stack_clash",
        challenge_type="flag_effect",
        category="hardening",
        difficulty=2,
        prompt="This flag inserts page-sized probes into large stack allocations to prevent jumping the guard page",
        answer="-fstack-clash-protection",
        hint="See: hardening/stack-clash",
        accept=["stack-clash", "stack clash"],
    ),
    Challenge(
        id="flag_zero_regs",
        challenge_type="flag_effect",
        category="hardening",
        difficulty=3,
        prompt="This flag clears all used registers before function return, mitigating info leaks and ROP gadgets",
        answer="-fzero-call-used-regs=used",
        hint="See: hardening/zero-call-used-regs",
        accept=["zero-call-used-regs", "zero call used regs"],
    ),
    Challenge(
        id="flag_qspectre",
        challenge_type="flag_effect",
        category="security",
        difficulty=3,
        prompt="This MSVC flag inserts LFENCE after bounds-check branches to mitigate Spectre v1 attacks",
        answer="/Qspectre",
        hint="See: hardening/msvc-qspectre",
        accept=["/qspectre", "qspectre"],
    ),
    Challenge(
        id="flag_guard_cf",
        challenge_type="flag_effect",
        category="control-flow",
        difficulty=3,
        prompt="This MSVC flag validates indirect calls at runtime via __guard_dispatch_icall_fptr",
        answer="/guard:cf",
        hint="See: hardening/msvc-guard-cf",
        accept=["/guard:cf", "guard:cf", "/guard"],
    ),

    # ===================================================================
    # Assembly Pattern → Optimization  (8 challenges)
    # ===================================================================
    Challenge(
        id="asm_cmov",
        challenge_type="asm_pattern",
        category="control-flow",
        difficulty=1,
        prompt="Seeing cmov instructions instead of a conditional branch (jcc + mov) indicates this optimization",
        answer="If-conversion (branch to conditional move)",
        hint="See: control-flow/if-conversion",
        accept=["if-conversion", "if conversion", "conditional move"],
    ),
    Challenge(
        id="asm_shift_for_mul",
        challenge_type="asm_pattern",
        category="arithmetic",
        difficulty=1,
        prompt="shl (shift left) used where the source code has multiplication indicates this optimization",
        answer="Strength reduction (multiply → shift)",
        hint="See: arithmetic/strength-reduction",
        accept=["strength reduction"],
    ),
    Challenge(
        id="asm_movabs_string",
        challenge_type="asm_pattern",
        category="string-literals",
        difficulty=1,
        prompt="A small strcpy compiled into 'mov DWORD PTR, 0x44434241' (ASCII packed into an immediate) shows...",
        answer="String literal inlining (immediate stores)",
        hint="See: string-literals/static-copy-1",
        accept=["string literal inlin", "immediate store"],
    ),
    Challenge(
        id="asm_jump_table",
        challenge_type="asm_pattern",
        category="control-flow",
        difficulty=2,
        prompt="A .rodata section with an array of addresses indexed by a variable indicates this switch optimization",
        answer="Jump table (O(1) dispatch instead of if-else chain)",
        hint="See: control-flow/switch-table",
        accept=["jump table"],
    ),
    Challenge(
        id="asm_jmp_self",
        challenge_type="asm_pattern",
        category="control-flow",
        difficulty=2,
        prompt="A recursive function that uses jmp to itself instead of call has been optimized by...",
        answer="Tail call optimization",
        hint="See: control-flow/tail-call",
        accept=["tail call"],
    ),
    Challenge(
        id="asm_magic_mul",
        challenge_type="asm_pattern",
        category="arithmetic",
        difficulty=2,
        prompt="Division by a constant compiled as multiplication by a magic number (e.g. 0xAAAAAAAB) plus a shift is...",
        answer="Strength reduction (division by multiplicative inverse)",
        hint="See: arithmetic/strength-reduction",
        accept=["strength reduction", "multiplicative inverse"],
    ),
    Challenge(
        id="asm_endbr64",
        challenge_type="asm_pattern",
        category="hardening",
        difficulty=2,
        prompt="ENDBR64 at each function entry point is inserted by which compiler feature?",
        answer="Intel CET / -fcf-protection (Indirect Branch Tracking)",
        hint="See: hardening/cf-protection",
        accept=["cet", "cf-protection", "cf protection", "indirect branch tracking"],
    ),
    Challenge(
        id="asm_xor_zero_regs",
        challenge_type="asm_pattern",
        category="hardening",
        difficulty=3,
        prompt="Multiple 'xor reg, reg' instructions immediately before ret indicate this hardening feature",
        answer="Zero-call-used-regs (-fzero-call-used-regs)",
        hint="See: hardening/zero-call-used-regs",
        accept=["zero-call-used-regs", "zero call used regs"],
    ),

    # ===================================================================
    # Scenario Comparison  (8 challenges)
    # ===================================================================
    Challenge(
        id="scen_unroll",
        challenge_type="scenario_compare",
        category="loops",
        difficulty=1,
        prompt="At -O2/-O3 but not -O0, a loop filling a small buffer with a constant is replaced by a single store. Why?",
        answer="Loop unrolling combined with dead store elimination",
        hint="See: loops/unrollme-1",
        accept=["loop unroll", "unrolling"],
    ),
    Challenge(
        id="scen_const_fold",
        challenge_type="scenario_compare",
        category="arithmetic",
        difficulty=1,
        prompt="At any optimization level except -O0, 'return 4 * 1024' compiles to 'mov eax, 4096' because of...",
        answer="Constant folding",
        hint="See: arithmetic/constant-folding",
        accept=["constant folding"],
    ),
    Challenge(
        id="scen_branch_elim",
        challenge_type="scenario_compare",
        category="control-flow",
        difficulty=1,
        prompt="At -O2+, 'if (sizeof(void*) == 8)' keeps only the true branch. This is called...",
        answer="Dead branch elimination (compile-time constant condition)",
        hint="See: control-flow/branch-elimination",
        accept=["dead branch", "branch elim"],
    ),
    Challenge(
        id="scen_vectorize",
        challenge_type="scenario_compare",
        category="simd",
        difficulty=2,
        prompt="At -O3 (but usually not -O2), a simple array addition loop gains SSE/AVX instructions because of...",
        answer="Auto-vectorization (SIMD)",
        hint="See: simd/auto-vectorize",
        accept=["vectori"],
    ),
    Challenge(
        id="scen_inline",
        challenge_type="scenario_compare",
        category="control-flow",
        difficulty=2,
        prompt="At -O2+, calls to small helper functions disappear from the assembly because of...",
        answer="Function inlining",
        hint="See: control-flow/inline-expansion",
        accept=["inlining", "inline"],
    ),
    Challenge(
        id="scen_licm",
        challenge_type="scenario_compare",
        category="loops",
        difficulty=2,
        prompt="At -O2+, 'base * scale' inside a loop is computed once before the loop. This optimization is called...",
        answer="Loop-Invariant Code Motion (LICM)",
        hint="See: loops/loop-invariant-motion",
        accept=["loop-invariant", "loop invariant", "licm"],
    ),
    Challenge(
        id="scen_ofast_nan",
        challenge_type="scenario_compare",
        category="arithmetic",
        difficulty=2,
        prompt="At -Ofast but not -O3, 'x != x' (NaN check) may be optimized to always return false because...",
        answer="-ffast-math assumes no NaN values exist",
        hint="See: arithmetic/fast-math",
        accept=["fast-math", "fast math", "no nan"],
    ),
    Challenge(
        id="scen_os_vs_o3",
        challenge_type="scenario_compare",
        category="loops",
        difficulty=3,
        prompt="-Os differs from -O3 mainly by avoiding optimizations that do what?",
        answer="Increase code size (e.g. aggressive unrolling, vectorization)",
        accept=["code size", "increase size"],
    ),

    # ===================================================================
    # Compiler Difference  (6 challenges)
    # ===================================================================
    Challenge(
        id="comp_canary_src",
        challenge_type="compiler_diff",
        category="hardening",
        difficulty=2,
        prompt="GCC reads the stack canary from %fs:0x28 (thread-local). Where does MSVC read it from?",
        answer="__security_cookie (a global, XORed with RSP)",
        hint="See: hardening/msvc-gs-canary",
        accept=["__security_cookie", "security_cookie"],
    ),
    Challenge(
        id="comp_fortify",
        challenge_type="compiler_diff",
        category="hardening",
        difficulty=2,
        prompt="With _FORTIFY_SOURCE=2 on GCC/glibc, strcpy is replaced by which checked function?",
        answer="__strcpy_chk",
        hint="See: hardening/fortify-source",
        accept=["__strcpy_chk", "strcpy_chk"],
    ),
    Challenge(
        id="comp_restrict",
        challenge_type="compiler_diff",
        category="simd",
        difficulty=2,
        prompt="The 'restrict' keyword tells the compiler pointers don't alias, enabling more aggressive...",
        answer="Vectorization and load/store optimization",
        hint="See: simd/restrict-pointer",
        accept=["vectori", "load/store", "load store"],
    ),
    Challenge(
        id="comp_cfg_vs_cet",
        challenge_type="compiler_diff",
        category="control-flow",
        difficulty=3,
        prompt="GCC/Clang use hardware ENDBR64 for indirect call protection. MSVC uses software-based...",
        answer="Control Flow Guard (/guard:cf) with __guard_dispatch_icall_fptr",
        hint="See: hardening/msvc-guard-cf",
        accept=["control flow guard", "/guard:cf", "guard:cf"],
    ),
    Challenge(
        id="comp_spectre",
        challenge_type="compiler_diff",
        category="security",
        difficulty=3,
        prompt="MSVC mitigates Spectre v1 with LFENCE via /Qspectre. What is Clang's alternative approach called?",
        answer="Speculative Load Hardening (-mspeculative-load-hardening)",
        hint="See: hardening/msvc-qspectre",
        accept=["speculative load hardening", "mspeculative"],
    ),
    Challenge(
        id="comp_loop_interchange",
        challenge_type="compiler_diff",
        category="loops",
        difficulty=3,
        prompt="Whether a compiler reorders nested loop indices for cache locality at -O3 varies by compiler. This is...",
        answer="Loop interchange",
        hint="See: loops/loop-interchange",
        accept=["loop interchange"],
    ),

    # ===================================================================
    # Security Implications  (10 challenges)
    # ===================================================================
    Challenge(
        id="sec_memset_removed",
        challenge_type="security",
        category="security",
        difficulty=1,
        prompt="A memset() to clear a password buffer may be removed by the optimizer because it is a...",
        answer="Dead store (buffer not read afterward)",
        hint="See: security/memset-removed",
        accept=["dead store"],
    ),
    Challenge(
        id="sec_stack_canary_purpose",
        challenge_type="security",
        category="hardening",
        difficulty=1,
        prompt="Stack canaries detect buffer overflows that overwrite the...",
        answer="Saved return address (stack smashing)",
        hint="See: hardening/stack-protector",
        accept=["return address", "stack smash"],
    ),
    Challenge(
        id="sec_null_check",
        challenge_type="security",
        category="security",
        difficulty=2,
        prompt="If you dereference a pointer BEFORE checking for NULL, the compiler may remove the check because...",
        answer="Dereferencing NULL is UB, so the compiler assumes the pointer is non-NULL",
        hint="See: security/null-check-removed",
        accept=["undefined behav", "ub", "assumes"],
    ),
    Challenge(
        id="sec_overflow_check",
        challenge_type="security",
        category="security",
        difficulty=2,
        prompt="A hand-written 'if (a + b < a)' overflow check may be removed because...",
        answer="Signed overflow is UB; the compiler assumes it never happens",
        hint="See: security/overflow-check-removed",
        accept=["signed overflow", "undefined behav", "ub"],
    ),
    Challenge(
        id="sec_infinite_loop",
        challenge_type="security",
        category="security",
        difficulty=2,
        prompt="A 'while(1);' loop with no side effects may be removed entirely because...",
        answer="A non-terminating loop with no observable side effects is UB in C11+",
        hint="See: security/infinite-loop-removed",
        accept=["undefined behav", "ub", "no observable side effect"],
    ),
    Challenge(
        id="sec_volatile_spin",
        challenge_type="security",
        category="security",
        difficulty=2,
        prompt="To prevent the compiler from removing an infinite busy-wait loop, use this keyword...",
        answer="volatile (or asm volatile with a memory clobber)",
        hint="See: security/infinite-loop-removed",
        accept=["volatile"],
    ),
    Challenge(
        id="sec_fortify_abort",
        challenge_type="security",
        category="hardening",
        difficulty=2,
        prompt="When FORTIFY_SOURCE detects a buffer overflow at runtime, the program...",
        answer="Aborts (calls __chk_fail / terminates immediately)",
        hint="See: hardening/fortify-sprintf",
        accept=["abort", "terminat", "__chk_fail"],
    ),
    Challenge(
        id="sec_strict_alias",
        challenge_type="security",
        category="security",
        difficulty=3,
        prompt="Casting float* to uint32_t* to read the bit pattern can produce wrong results at -O2+ because of...",
        answer="Strict aliasing (incompatible pointer types assumed not to alias)",
        hint="See: security/strict-aliasing",
        accept=["strict alias"],
    ),
    Challenge(
        id="sec_lfence_purpose",
        challenge_type="security",
        category="security",
        difficulty=3,
        prompt="LFENCE instructions after bounds checks prevent speculative execution from leaking data via...",
        answer="Cache side channels (Spectre v1)",
        hint="See: hardening/msvc-qspectre",
        accept=["cache side channel", "spectre"],
    ),
    Challenge(
        id="sec_shadow_stack",
        challenge_type="security",
        category="control-flow",
        difficulty=3,
        prompt="Intel CET's shadow stack prevents ROP attacks by comparing return addresses against a hardware-maintained...",
        answer="Shadow stack (second, read-only copy of return addresses)",
        hint="See: hardening/cf-protection",
        accept=["shadow stack"],
    ),

    # ===================================================================
    # True/False Conceptual  (10 challenges)
    # ===================================================================
    Challenge(
        id="tf_volatile_all",
        challenge_type="true_false",
        category="memory",
        difficulty=1,
        prompt="True or False: 'volatile' prevents ALL optimizations on a variable",
        answer="False \u2014 it only prevents removing/reordering loads and stores to that variable",
        hint="See: memory/volatile-access",
        accept=["false"],
    ),
    Challenge(
        id="tf_inline_recursive",
        challenge_type="true_false",
        category="control-flow",
        difficulty=1,
        prompt="True or False: Recursive functions can always be fully inlined by the compiler",
        answer="False \u2014 recursive inlining would be infinite; compilers may partially inline a few levels",
        hint="See: control-flow/inline-expansion",
        accept=["false"],
    ),
    Challenge(
        id="tf_os_enables_o2",
        challenge_type="true_false",
        category="loops",
        difficulty=1,
        prompt="True or False: -Os enables the same optimizations as -O2, except those that increase code size",
        answer="True",
        accept=["true"],
    ),
    Challenge(
        id="tf_padding_order",
        challenge_type="true_false",
        category="memory",
        difficulty=1,
        prompt="True or False: Reordering struct fields from {char, int, char, int} to {int, int, char, char} can reduce size",
        answer="True \u2014 reduces wasted padding from 6 bytes to 2",
        hint="See: memory/struct-padding",
        accept=["true"],
    ),
    Challenge(
        id="tf_strict_alias_default",
        challenge_type="true_false",
        category="security",
        difficulty=2,
        prompt="True or False: Strict aliasing is enabled by default at -O2 and above in GCC",
        answer="True \u2014 -fstrict-aliasing is part of -O2; use -fno-strict-aliasing to disable",
        hint="See: security/strict-aliasing",
        accept=["true"],
    ),
    Challenge(
        id="tf_union_type_pun",
        challenge_type="true_false",
        category="security",
        difficulty=2,
        prompt="True or False: Type punning through a union is undefined behavior in C99",
        answer="False \u2014 union type punning is well-defined in C99+ (unlike pointer casts)",
        hint="See: security/strict-aliasing",
        accept=["false"],
    ),
    Challenge(
        id="tf_dead_code_ub",
        challenge_type="true_false",
        category="security",
        difficulty=2,
        prompt="True or False: The compiler can assume that undefined behavior never occurs, and optimize accordingly",
        answer="True \u2014 this is how overflow checks and NULL checks get removed",
        hint="See: security/overflow-check-removed",
        accept=["true"],
    ),
    Challenge(
        id="tf_stack_clash",
        challenge_type="true_false",
        category="hardening",
        difficulty=2,
        prompt="True or False: Stack clash protection adds NEW guard pages between the stack and heap",
        answer="False \u2014 it inserts probes to ensure existing guard pages are not skipped by large allocations",
        hint="See: hardening/stack-clash",
        accept=["false"],
    ),
    Challenge(
        id="tf_restrict_cpp",
        challenge_type="true_false",
        category="simd",
        difficulty=2,
        prompt="True or False: The 'restrict' keyword is part of the C++ standard",
        answer="False \u2014 restrict is C99 only; C++ compilers may support __restrict as an extension",
        hint="See: simd/restrict-pointer",
        accept=["false"],
    ),
    Challenge(
        id="tf_simd_o3",
        challenge_type="true_false",
        category="simd",
        difficulty=1,
        prompt="True or False: GCC/Clang typically enable auto-vectorization at -O2 (not just -O3)",
        answer="False \u2014 auto-vectorization usually requires -O3 or -ftree-vectorize",
        hint="See: simd/auto-vectorize",
        accept=["false"],
    ),
    Challenge(
        id="asm_string_pool",
        challenge_type="asm_pattern",
        category="string-literals",
        difficulty=1,
        prompt="Two identical string literals in different functions sharing the same .rodata address demonstrates...",
        answer="String pooling (identical strings merged by the linker/compiler)",
        hint="See: string-literals/static-copy-1",
        accept=["string pool"],
    ),
    Challenge(
        id="tf_msvc_cookie_xor",
        challenge_type="true_false",
        category="hardening",
        difficulty=3,
        prompt="True or False: MSVC XORs __security_cookie with RSP so that every stack frame has a unique canary",
        answer="True \u2014 a leaked canary from one frame cannot be reused in another",
        hint="See: hardening/msvc-gs-canary",
        accept=["true"],
    ),

    # ===================================================================
    # Padding / Stack-Reuse Leak  (4 challenges)
    # ===================================================================
    Challenge(
        id="sec_padding_leak",
        challenge_type="security",
        category="security",
        difficulty=2,
        prompt="Sending a struct over the network with field-by-field assignment can leak stack data through...",
        answer="Uninitialized padding bytes (alignment gaps between fields)",
        hint="See: security/padding-leak",
        accept=["padding", "alignment"],
    ),
    Challenge(
        id="sec_stack_reuse_leak",
        challenge_type="security",
        category="security",
        difficulty=2,
        prompt="A function's local buffer sent over the network may contain secrets from a prior call due to...",
        answer="Stack slot reuse (compiler reuses stack space for non-overlapping lifetimes)",
        hint="See: security/padding-leak",
        accept=["stack reuse", "stack slot"],
    ),
    Challenge(
        id="tf_padding_zeroed",
        challenge_type="true_false",
        category="security",
        difficulty=2,
        prompt="True or False: Assigning every field of a struct guarantees all bytes (including padding) are initialized",
        answer="False \u2014 field assignment skips padding bytes; use memset(&s, 0, sizeof(s)) first",
        hint="See: security/padding-leak",
        accept=["false"],
    ),
    Challenge(
        id="scen_padding_fix",
        challenge_type="scenario_compare",
        category="security",
        difficulty=1,
        prompt="To prevent leaking stack data through struct padding when sending over a network, zero the struct with...",
        answer="memset(&rec, 0, sizeof(rec)) before assigning fields",
        hint="See: security/padding-leak",
        accept=["memset"],
    ),

    # ===================================================================
    # Integer Promotion  (2 challenges)
    # ===================================================================
    Challenge(
        id="tf_promotion_tilde",
        challenge_type="true_false",
        category="arithmetic",
        difficulty=2,
        prompt="True or False: In C, ~(uint8_t)0xFF evaluates to 0x00",
        answer="False \u2014 uint8_t is promoted to int before ~, so ~(int)0xFF = -256, not 0",
        hint="See: arithmetic/integer-promotion",
        accept=["false"],
    ),
    Challenge(
        id="scen_promotion_dead",
        challenge_type="scenario_compare",
        category="arithmetic",
        difficulty=2,
        prompt="At -O2, 'if (~byte == 0)' where byte is uint8_t compiles to constant 'return 0' because of...",
        answer="Integer promotion: ~byte promotes to int, so the result is never 0",
        hint="See: arithmetic/integer-promotion",
        accept=["integer promotion", "int promotion"],
    ),

    # ===================================================================
    # Dead Code After Noreturn  (2 challenges)
    # ===================================================================
    Challenge(
        id="sec_noreturn_fallthrough",
        challenge_type="security",
        category="control-flow",
        difficulty=3,
        prompt="If a function marked __attribute__((noreturn)) actually returns, execution may...",
        answer="Fall through into the next function's code (all code after the call was eliminated)",
        hint="See: control-flow/dead-code-after-noreturn",
        accept=["fall through", "next function", "dead code"],
    ),
    Challenge(
        id="tf_noreturn_cleanup",
        challenge_type="true_false",
        category="control-flow",
        difficulty=2,
        prompt="True or False: Code placed after a call to a noreturn function is guaranteed to remain in the binary",
        answer="False \u2014 the compiler eliminates it as unreachable dead code",
        hint="See: control-flow/dead-code-after-noreturn",
        accept=["false"],
    ),

    # ===================================================================
    # Loop Unswitching  (2 challenges)
    # ===================================================================
    Challenge(
        id="asm_loop_unswitched",
        challenge_type="asm_pattern",
        category="loops",
        difficulty=2,
        prompt="Two separate loops in the assembly \u2014 each calling a different function \u2014 where the source has one loop with an if/else indicates...",
        answer="Loop unswitching (loop-invariant conditional hoisted outside)",
        hint="See: loops/loop-unswitching",
        accept=["loop unswitching", "loop unswitch"],
    ),
    Challenge(
        id="scen_unswitching_tradeoff",
        challenge_type="scenario_compare",
        category="loops",
        difficulty=2,
        prompt="Loop unswitching improves runtime by removing a branch from the hot loop, but the trade-off is...",
        answer="Doubled code size for the loop body (suppressed at -Os)",
        hint="See: loops/loop-unswitching",
        accept=["code size", "doubled", "duplicate"],
    ),

    # ===================================================================
    # memcmp Timing  (2 challenges)
    # ===================================================================
    Challenge(
        id="sec_memcmp_timing",
        challenge_type="security",
        category="security",
        difficulty=2,
        prompt="Using memcmp() to verify authentication tokens is vulnerable to...",
        answer="Timing side channel (early exit reveals how many bytes matched)",
        hint="See: security/memcmp-timing",
        accept=["timing", "side channel"],
    ),
    Challenge(
        id="scen_constant_time",
        challenge_type="scenario_compare",
        category="security",
        difficulty=2,
        prompt="A constant-time comparison XORs every byte pair and ORs the results into a volatile accumulator to prevent...",
        answer="The compiler from short-circuiting (branching on partial results)",
        hint="See: security/memcmp-timing",
        accept=["short-circuit", "short circuit", "branch"],
    ),

    # ===================================================================
    # memcpy Direction  (2 challenges)
    # ===================================================================
    Challenge(
        id="sec_memcpy_overlap",
        challenge_type="security",
        category="security",
        difficulty=1,
        prompt="Using memcpy() with overlapping source and destination buffers is...",
        answer="Undefined behavior \u2014 use memmove() for overlapping regions",
        hint="See: security/memcpy-direction",
        accept=["undefined behav", "ub", "memmove"],
    ),
    Challenge(
        id="tf_memmove_overlap",
        challenge_type="true_false",
        category="security",
        difficulty=1,
        prompt="True or False: memmove() handles overlapping memory regions correctly, unlike memcpy()",
        answer="True \u2014 memmove checks direction and copies safely; memcpy may copy in any order",
        hint="See: security/memcpy-direction",
        accept=["true"],
    ),

    # ===================================================================
    # Return Value Overwrite  (2 challenges)
    # ===================================================================
    Challenge(
        id="sec_dangling_local",
        challenge_type="security",
        category="security",
        difficulty=2,
        prompt="Returning a pointer to a local variable is UB; at -O2 GCC may replace the entire function with...",
        answer="return NULL (xor eax, eax; ret) \u2014 the local is optimized away entirely",
        hint="See: security/return-value-overwrite",
        accept=["null", "xor eax"],
    ),
    Challenge(
        id="tf_dangling_o0",
        challenge_type="true_false",
        category="security",
        difficulty=2,
        prompt="True or False: Returning a pointer to a local variable may appear to work at -O0 but fail at -O2",
        answer="True \u2014 at -O0 the stack frame is intact; at -O2 the local may be in a register or eliminated",
        hint="See: security/return-value-overwrite",
        accept=["true"],
    ),

    # ===================================================================
    # Signed/Unsigned Compare  (2 challenges)
    # ===================================================================
    Challenge(
        id="sec_signed_unsigned",
        challenge_type="security",
        category="security",
        difficulty=2,
        prompt="A negative signed int compared against size_t bypasses bounds checks because...",
        answer="Implicit conversion to unsigned wraps the negative value to a huge number",
        hint="See: security/signed-unsigned-compare",
        accept=["unsigned", "wrap", "implicit conver", "promot"],
    ),
    Challenge(
        id="tf_negative_size_t",
        challenge_type="true_false",
        category="security",
        difficulty=1,
        prompt="True or False: Casting (int)-1 to size_t yields 0",
        answer="False \u2014 it yields SIZE_MAX (0xFFFFFFFFFFFFFFFF on 64-bit)",
        hint="See: security/signed-unsigned-compare",
        accept=["false"],
    ),

    # ===================================================================
    # Type Width Truncation  (2 challenges)
    # ===================================================================
    Challenge(
        id="sec_truncation",
        challenge_type="security",
        category="security",
        difficulty=2,
        prompt="Assigning a size_t to unsigned short before a bounds check fails because...",
        answer="High bits are silently truncated (e.g. 65540 becomes 4, passing a <= 1024 check)",
        hint="See: security/type-width-truncation",
        accept=["truncat", "high bits"],
    ),
    Challenge(
        id="asm_truncation_cmpw",
        challenge_type="asm_pattern",
        category="security",
        difficulty=3,
        prompt="A 16-bit comparison (cmpw) where the source code uses size_t indicates...",
        answer="Integer truncation vulnerability (narrowing conversion before bounds check)",
        hint="See: security/type-width-truncation",
        accept=["truncat", "narrowing"],
    ),

    # ===================================================================
    # VLA Stack Overflow  (2 challenges)
    # ===================================================================
    Challenge(
        id="sec_vla_stack",
        challenge_type="security",
        category="security",
        difficulty=2,
        prompt="A Variable-Length Array (VLA) sized by untrusted input can...",
        answer="Exhaust the stack instantly, potentially bypassing stack clash protection",
        hint="See: security/vla-stack-overflow",
        accept=["stack", "exhaust", "overflow"],
    ),
    Challenge(
        id="tf_vla_bounds",
        challenge_type="true_false",
        category="security",
        difficulty=1,
        prompt="True or False: The C compiler inserts bounds checks for Variable-Length Array sizes",
        answer="False \u2014 VLAs have no runtime size validation; the programmer must check bounds",
        hint="See: security/vla-stack-overflow",
        accept=["false"],
    ),
]
